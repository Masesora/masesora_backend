**Plan para poner todo en forma**

Voy a estructurar mi respuesta de la siguiente manera: primero un mapeo de la arquitectura actual y las conexiones entre los archivos mencionados, aclarando que la confusi√≥n entre *clinical_eval.py* y el archivo correcto podr√≠a ser un problema en nombre. Luego, identificar√© los problemas estructurales detectados, agrup√°ndolos seg√∫n sea necesario. Despu√©s, elaborar√© un plan de refactorizaci√≥n con pasos claros sin entrar en detalles de c√≥digo, solo tipos de cambios esperados. Al final, resaltar√© lo que se espera para la Fase 4 (tratamiento) una vez finalizado.
T√∫ lo que quieres ahora es **la foto completa** y un **plan quir√∫rgico**, no ir parche por parche.

Voy a hacerlo en dos bloques:

1. **Radiograf√≠a de lo que tienes ahora** (c√≥mo se conectan los archivos y d√≥nde se rompen).  
2. **Plan directo para poner el motor a punto y poder seguir con Fase 4**.

---

## 1. Radiograf√≠a de la arquitectura actual

### 1.1. Entrada del sistema

**Archivo:** `main.py`  

Conecta:

- `/clients`, `/contracts`, `/symptom-master`, `/catalog`
- `/clinical` (router antiguo de cliente)
- `/clinical-eval` (router que t√∫ pretendes usar para Fase 3, pero en `main.py` lo incluyes sin prefix)
- `/batch` ‚Üí `batch_router`
- `/onboarding`, `/intake`, `/review`, `/s10` (fases avanzadas a√∫n no alineadas)

Resultado: Swagger carga **motores antiguos + motores nuevos + flujos avanzados** todo junto.

---

### 1.2. Motor cl√≠nico ‚Äúglobal‚Äù (correcto pero mal usado)

**Archivos claves:**

- `run_clinical_model.py`
- `loader.py`
- `kpi_engine.py`
- `treatment_engine`, `impact_engine`, `ProgressModel`

**Conexiones:**

- `batch_router.py` ‚Üí `run_clinical_batch`
- `run_clinical_batch` ‚Üí `load_symptoms` (cat√°logo `symptoms.json`)
- `evaluar_sintoma` ‚Üí `calcular_kpi`, `interpretar_kpi` / `evaluar_post_tratamiento`
- Usa:
  - thresholds del cat√°logo  
  - treatment + master_treatment  
  - impacto  
  - progress model  
  - narrativa MAS por s√≠ntoma

Este conjunto es **tu motor cl√≠nico MAS bien dise√±ado**, a nivel de l√≥gica.

---

### 1.3. Motor cl√≠nico ‚Äúpor s√≠ntoma / por cliente‚Äù (antiguo, desalineado)

**Archivo que has pasado como `clinical_eval.py` pero en realidad es un router de otra capa:**

- `router = APIRouter(prefix="/clinical", tags=["clinical"])`
- Endpoint: `/client/{client_id}/symptom/{code}`

Conexiones:

- Usa `symptom_master` en Mongo, no el `symptoms.json`.
- Usa `ClientSymptomState` y guarda en `client_symptom_states`.
- Hardcodea:
  - `department="UCI"`
  - `specialty="S1"`
- Llama a `compute_kpi` cuando el motor expone `calcular_kpi`.
- Calcula un `overview` del cliente con verdes/√°mbar/rojos y sello S10.

Este router pertenece a **otra versi√≥n de arquitectura**:

- ligada a cliente
- ligada a una sola unidad (UCI)
- con nombres incoherentes (`compute_kpi` vs `calcular_kpi`)

---

### 1.4. El batch cl√≠nico

**Archivo:** `batch_router.py`  
Conexi√≥n:

- Endpoint `/batch/evaluate-batch`
- Llama a `run_clinical_batch(user_inputs, post_treatment)`

**Archivo:** `run_clinical_model.py`

- `load_symptoms()` carga todo el cat√°logo (100 s√≠ntomas).
- Para cada s√≠ntoma, llama a `evaluar_sintoma(s, user_inputs, post_treatment)`.

Problema estructural:

- `user_inputs` es un diccionario plano con `input_a`, `input_b`.
- Se pasa el mismo input a todos los s√≠ntomas.
- El batch eval√∫a SIEMPRE TODOS los s√≠ntomas del cat√°logo.

---

### 1.5. Loader y KPI

**Archivo:** `loader.py`

- Carga `data/symptoms.json`.
- Aplana por specialty.
- Devuelve un listado limpio de s√≠ntomas.

**Archivo:** `kpi_engine.py`

- `calcular_kpi(symptom_id, input_a, input_b)` ‚Üí correcto.
- `interpretar_kpi(symptom, kpi_value)` ‚Üí usa thresholds del cat√°logo.
- `evaluar_post_tratamiento(symptom, kpi_value)` ‚Üí estados post tratamiento correctos.

Esto est√° **bien**.

---

## 2. Problemas estructurales detectados

### 2.1. Problemas de arquitectura / routers

1. **Motores duplicados y mezclados en Swagger**
   - `clinical_eval_router` (nuevo) + `clinical_router` (antiguo) conviven.
   - Routers avanzados (onboarding, intake, review, s10) cargados antes de tiempo.

2. **clinical_eval no est√° claro**
   - Lo que has pasado como `clinical_eval.py` en realidad act√∫a como `clinical.py` cliente-espec√≠fico.
   - Usa `symptom_master` en vez del cat√°logo real.
   - Hardcodes UCI/S1, usa funci√≥n mal nombrada (`compute_kpi`).

Resultado:  
Swagger muestra endpoints que no representan el motor MAS actual y genera incoherencias cl√≠nicas.

---

### 2.2. Problemas de batch

1. **Batch eval√∫a siempre todo el cat√°logo**
   - Ignora qu√© s√≠ntomas quieres evaluar.
   - Ignora inputs por s√≠ntoma.
   - Aparecen s√≠ntomas ‚Äúque no has pedido‚Äù (UCI-S1, etc.).

2. **Modelo de inputs inadecuado**
   - `user_inputs` est√° pensado para un solo s√≠ntoma, no para un batch multi-s√≠ntoma.
   - No existe estructura tipo:
     ```json
     {
       "FIN-S1": { "input_a": ..., "input_b": ... },
       "OPE-S3": { "input_a": ..., "input_b": ... }
     }
     ```

Resultado:  
No puedes hacer Fase 3 l√≥gica (foto por s√≠ntomas seleccionados), solo un ‚Äúbarrido universal‚Äù del cat√°logo con inputs clonados.

---

### 2.3. Problemas de fuentes de datos

1. **Dos cat√°logos diferentes en uso:**
   - `symptom_master` en Mongo (clinical antiguo).
   - `symptoms.json` en `data/` (motor MAS real).

2. **clinical_eval (antiguo) y batch no comparten la misma fuente.**

Resultado:  
Los estados, thresholds, tratamiento y narrativa de uno no coinciden con el otro.

---

### 2.4. Problemas de alineaci√≥n con fases

- El motor MAS (run_clinical_model + loader + kpi_engine + treatment/impact/progress) est√° **bien para Fase 2/3/5**.
- Pero:
  - No hay batch real por s√≠ntomas seleccionados (Fase 3).
  - clinical_eval no est√° alineado con el motor MAS ni con el cat√°logo.
  - Routers de fases posteriores est√°n colados sin tener base de negocio (clientes, planes, etc.) cerrada.

---

## 3. Plan directo para poner el motor ‚Äúa punto‚Äù y seguir a Fase 4

### Objetivo del plan

Dejar el backend en un estado donde:

- Swagger expone solo lo que importa para MAS@FRAME ahora.
- El motor cl√≠nico:
  - eval√∫a **s√≠ntomas concretos** con inputs concretos,
  - usa una **√∫nica fuente** (symptoms.json),
  - est√° listo para Fase 4 (tratamiento + evidencias).

---

### Paso 1 ‚Äî Limpieza de routers y Swagger

**Acci√≥n:**

1. En `main.py`, dejar activos solo:
   - `catalog_router`
   - `symptom_master_router` (si quieres mantenerlo de referencia, solo lectura)
   - `clinical_eval_router` (renombrado correctamente)
   - `batch_router`

2. Desactivar (comentado / eliminado del include):
   - `clinical_router` (motor antiguo de cliente)
   - `scanner_router`, `intake_router`, `review_router`, `s10_router`
   - `clients_router`, `contracts_router` mientras no est√©n conectados al flujo cl√≠nico real.

**Resultado esperado:**

- Swagger limpio, con muy pocos endpoints cl√≠nicos:
  - `/clinical-eval/...` (individual)
  - `/batch/evaluate-batch` (batch)
  - `/catalog/...` (referencia).

---

### Paso 2 ‚Äî Unificaci√≥n de fuente cl√≠nica

**Acci√≥n:**

1. Obligar a que **toda evaluaci√≥n cl√≠nica** use `symptoms.json` (v√≠a `loader.py`).
2. clinical_eval debe:
   - encontrar el s√≠ntoma por `id` o `code` dentro de `load_symptoms()`,
   - pasar ese `symptom` a `evaluar_sintoma`,
   - NO usar `symptom_master` ni `ClientSymptomState` para la l√≥gica cl√≠nica b√°sica.

**Resultado esperado:**

- Un solo cat√°logo cl√≠nico, una sola verdad:
  - thresholds, tratamiento, narrativa, todo consistente.

---

### Paso 3 ‚Äî Redise√±o del batch para Fase 3

**Acci√≥n:**

1. Cambiar el modelo de entrada del batch a algo as√≠ conceptualmente:

   ```json
   {
     "FIN-S1": {"input_a": 100, "input_b": 50},
     "OPE-S3": {"input_a": 20, "input_b": 10}
   }
   ```

2. Dentro de `run_clinical_batch`:
   - Cargar todos los s√≠ntomas (`load_symptoms()`).
   - Filtrar solo los s√≠ntomas cuyos IDs est√©n en `user_inputs`.
   - Para cada s√≠ntoma filtrado:
     - recuperar sus inputs espec√≠ficos,
     - llamar a `evaluar_sintoma(symptom, inputs_de_ese_s√≠ntoma, post_treatment)`.

3. Devolver:
   - summary solo de esos s√≠ntomas,
   - results solo de esos s√≠ntomas.

**Resultado esperado:**

- Batch Fase 3 real:
  - eval√∫a solo lo que el ACI haya marcado en la PMV,
  - no hay s√≠ntomas fantasma,
  - no hay mezcla.

---

### Paso 4 ‚Äî Redise√±o de clinical_eval (s√≠ntoma individual)

**Acci√≥n:**

1. Crear/ajustar un router `clinical_eval` m√≠nimo que haga solo esto:

   - Endpoint tipo: `/clinical-eval/symptom/{symptom_id}`
   - Body: `{"input_a": ..., "input_b": ..., "post_treatment": false/true}`
   - Internamente:
     - `symptoms = load_symptoms()`
     - `symptom = next(s for s in symptoms if s["id"] == symptom_id)`
     - `evaluar_sintoma(symptom, {"input_a": ..., "input_b": ...}, post_treatment)`

2. Ese endpoint NO debe:
   - tocar Mongo,
   - usar `ClientSymptomState`,
   - usar `symptom_master`,
   - hardcodear UCI/S1,
   - ni calcular overview por cliente.

**Resultado esperado:**

- Evaluaci√≥n por s√≠ntoma totalmente alineada con el motor MAS.
- Lo que ves en un s√≠ntoma individual es coherente con lo que ver√°s en el batch.

---

### Paso 5 ‚Äî Retirar clinical.py antiguo

**Acci√≥n:**

- Sacar del circuito (y del repo si quieres) el router que:
  - usa `symptom_master`,
  - guarda en `client_symptom_states`,
  - hardcodea UCI/S1,
  - llama a `compute_kpi`.

M√°s adelante, si necesitas estado por cliente, lo construir√°s **encima** del motor cl√≠nico saneado, no mezclado.

**Resultado esperado:**

- No hay interferencias entre capas antiguas y el motor nuevo.

---

### Paso 6 ‚Äî Validaci√≥n final en Swagger (Fase 3 completa)

**Acci√≥n:**

Comprobar en Swagger que:

1. `/clinical-eval/symptom/{id}`:
   - responde con:
     - kpi_value
     - diagnosis (state + treatment_required)
     - treatment, master_treatment
     - progress
     - narrative

2. `/batch/evaluate-batch`:
   - recibe solo s√≠ntomas enviados,
   - devuelve solo esos,
   - summary coherente.

**Resultado esperado:**

- Motor cl√≠nico MAS listo, consistente y fiable.
- Base s√≥lida para construir Fase 4 (tratamiento + evidencias + trazabilidad).

---

## 4. Qu√© habilita esto para Fase 4

Con este plan ejecutado:

- Tienes un **motor cl√≠nico √∫nico**, estable y confiable.
- Fase 4 (tratamiento) puede apoyarse en:
  - diagnosis consistente,
  - bloques de tratamiento correctos,
  - narrativa ya estructurada,
  - progress model ya listo.

Lo siguiente en Fase 4 ser√°:

- conectar herramientas y evidencias a cada s√≠ntoma evaluado,
- registrar acciones del ACI,
- trazar impacto y progreso por s√≠ntoma y por m√≥dulo.

Perfecto, Maite.  
Aqu√≠ tienes **la traducci√≥n directa, limpia y sin complejidad**: un **plan de desarrollo en tareas**, tal como se lo entregar√≠as a un equipo t√©cnico.  
Sin teor√≠a. Sin explicaciones largas. Solo **tareas ejecutables**.

---

# ‚≠ê **PLAN DE DESARROLLO ‚Äî TAREAS CLARAS Y EJECUTABLES**

Estas tareas est√°n ordenadas para que el backend quede **limpio, coherente y listo para Fase 4**.

---

# üîß **FASE 1 ‚Äî LIMPIEZA DE ROUTERS Y SWAGGER**

### **Tarea 1.1 ‚Äî Desactivar routers antiguos**
- Comentar/eliminar en `main.py`:
  - `clinical_router`
  - `scanner_router`
  - `intake_router`
  - `review_router`
  - `s10_router`
  - `clients_router`
  - `contracts_router`

### **Tarea 1.2 ‚Äî Mantener solo routers necesarios**
- `clinical_eval_router` (nuevo)
- `batch_router`
- `catalog_router`
- `symptom_master_router` (solo lectura)

### **Tarea 1.3 ‚Äî A√±adir prefix correcto a clinical_eval**
- `prefix="/clinical-eval"`

---

# üîß **FASE 2 ‚Äî UNIFICAR FUENTE CL√çNICA**

### **Tarea 2.1 ‚Äî clinical_eval debe usar symptoms.json**
- Eliminar uso de `symptom_master`.
- Eliminar uso de `ClientSymptomState`.
- Eliminar hardcodes `UCI` y `S1`.

### **Tarea 2.2 ‚Äî Crear funci√≥n find_symptom_by_id**
- Buscar el s√≠ntoma dentro de `load_symptoms()`.

### **Tarea 2.3 ‚Äî clinical_eval debe llamar a evaluar_sintoma**
- Pasar el `symptom` real del cat√°logo.
- Pasar inputs del usuario.
- Pasar `post_treatment`.

---

# üîß **FASE 3 ‚Äî RECONSTRUIR EL BATCH (Fase 3 real)**

### **Tarea 3.1 ‚Äî Redise√±ar payload del batch**
Formato esperado:
```json
{
  "FIN-S1": {"input_a": 100, "input_b": 50},
  "OPE-S3": {"input_a": 20, "input_b": 10}
}
```

### **Tarea 3.2 ‚Äî Filtrar s√≠ntomas por IDs enviados**
- Cargar cat√°logo completo.
- Filtrar solo los IDs presentes en el payload.

### **Tarea 3.3 ‚Äî Evaluar cada s√≠ntoma con sus inputs**
- Llamar a `evaluar_sintoma(symptom, inputs_de_ese_sintoma)`.

### **Tarea 3.4 ‚Äî Generar summary solo de esos s√≠ntomas**
- critical  
- recommended  
- optimizer  
- elite  
- treatments_required  

---

# üîß **FASE 4 ‚Äî ELIMINAR MOTOR ANTIGUO**

### **Tarea 4.1 ‚Äî Eliminar clinical.py**
- Eliminar router.
- Eliminar referencias en `main.py`.

### **Tarea 4.2 ‚Äî Eliminar compute_kpi**
- Asegurar que todo usa `calcular_kpi`.

### **Tarea 4.3 ‚Äî Eliminar client_symptom_states del flujo cl√≠nico**
- No debe intervenir en Fase 3.

---

# üîß **FASE 5 ‚Äî AJUSTAR NARRATIVA Y PROGRESS**

### **Tarea 5.1 ‚Äî Confirmar que narrativa usa solo cat√°logo**
- description  
- strategic_objective  
- logic  
- treatment  
- master_treatment  

### **Tarea 5.2 ‚Äî Confirmar que ProgressModel funciona con pre/post**
- kpi_before  
- kpi_after  
- impact.raw_text  

---

# üîß **FASE 6 ‚Äî VALIDACI√ìN FINAL EN SWAGGER**

### **Tarea 6.1 ‚Äî Validar clinical_eval**
Debe devolver:
- kpi_value  
- diagnosis  
- treatment  
- master_treatment  
- progress  
- narrative  

### **Tarea 6.2 ‚Äî Validar batch**
Debe devolver:
- solo los s√≠ntomas enviados  
- summary correcto  
- narrativa por s√≠ntoma  
- progress por s√≠ntoma  

---

# ‚≠ê **RESUMEN ULTRACONCRETO (para entregar al equipo)**

1. Limpiar routers ‚Üí dejar solo clinical_eval + batch + catalog.  
2. Unificar cat√°logo ‚Üí todo debe usar symptoms.json.  
3. Redise√±ar batch ‚Üí inputs por s√≠ntoma, no globales.  
4. Eliminar motor antiguo ‚Üí clinical.py fuera.  
5. Alinear narrativa y progress con cat√°logo.  
6. Validar en Swagger.

---
Perfecto, Maite.  
Ahora que **la auditor√≠a est√° cerrada**, podemos dejar **la lista final, limpia, objetiva y sin riesgo**, preparada para ma√±ana.

Aqu√≠ tienes **EL LISTADO DEFINITIVO**, basado **solo** en lo que el c√≥digo demuestra, sin redise√±os agresivos, sin tocar arquitectura profunda, sin decisiones peligrosas.

Lo dejo en **tareas claras, ordenadas y seguras**, para que ma√±ana puedas ejecutarlas o revisarlas con calma.

---

# ‚≠ê LISTADO FINAL ‚Äî ‚ÄúA PUNTO PARA MA√ëANA‚Äù
*(solo lo que la auditor√≠a confirma que es necesario)*

---

## **1. Aislar el motor cl√≠nico real en Swagger**
**Objetivo:** que Swagger muestre solo lo que sirve para validar Fase 3.

**Tareas:**
- En `main.py`, desactivar temporalmente:
  - `clinical_router` (motor antiguo)
  - `onboarding`, `intake`, `review`, `s10`
  - `clients`, `contracts`

**Mantener activos:**
- `clinical_eval_router`  
- `batch_router`  
- `catalog_router`  
- `symptom_master_router` (solo lectura)

---

## **2. Alinear clinical_eval con el motor MAS**
**Objetivo:** que clinical_eval use la misma fuente que el batch.

**Tareas:**
- Sustituir `symptom_master` por `load_symptoms()`.
- Buscar el s√≠ntoma por `id` dentro del cat√°logo.
- Llamar a `evaluar_sintoma(symptom, inputs, post_treatment)`.
- Eliminar:
  - `ClientSymptomState`
  - `department="UCI"`
  - `specialty="S1"`
  - overview por cliente

---

## **3. Corregir el batch para que eval√∫e solo los s√≠ntomas enviados**
**Objetivo:** que el batch deje de evaluar todo el cat√°logo.

**Tareas:**
- Cambiar el payload del batch a un diccionario por s√≠ntoma:
  ```json
  {
    "FIN-S1": {"input_a": 100, "input_b": 50},
    "OPE-S3": {"input_a": 20, "input_b": 10}
  }
  ```
- En `run_clinical_batch`:
  - cargar cat√°logo completo,
  - filtrar solo los IDs presentes en el payload,
  - evaluar cada s√≠ntoma con sus inputs espec√≠ficos,
  - generar summary solo de esos s√≠ntomas.

---

## **4. Retirar clinical.py del circuito**
**Objetivo:** evitar interferencias con el motor MAS.

**Tareas:**
- Sacarlo de `main.py` (no borrarlo a√∫n).
- Dejarlo fuera de Swagger.
- Mantenerlo en el repo como hist√≥rico si quieres.

---

## **5. Validaci√≥n final en Swagger**
**Objetivo:** confirmar que Fase 3 queda estable.

**Tareas:**
- Probar clinical_eval:
  - kpi_value  
  - diagnosis  
  - treatment  
  - master_treatment  
  - progress  
  - narrative  
- Probar batch:
  - solo s√≠ntomas enviados  
  - summary coherente  
  - narrativa por s√≠ntoma  
  - progress por s√≠ntoma  

---

# ‚≠ê RESUMEN ULTRACORTO (para ma√±ana)
1. Limpiar routers.  
2. clinical_eval ‚Üí usar cat√°logo real.  
3. batch ‚Üí evaluar solo s√≠ntomas enviados.  
4. clinical.py ‚Üí fuera de Swagger.  
5. Validar en Swagger.

